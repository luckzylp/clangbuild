name: Build and Release Static libclang (Alpine)

on:
  workflow_dispatch:
    inputs:
      ref:
        description: "Optional: Git ref (tag or commit) of LLVM to build"
        required: false
        default: ""

jobs:
  get-llvm-tag:
    runs-on: ubuntu-latest
    outputs:
      llvm_tag: ${{ steps.determine_ref.outputs.llvm_ref }}
      clang_version: ${{ steps.determine_ref.outputs.clang_version }}
      commit_sha: ${{ steps.get_sha.outputs.commit_sha }}
    steps:
      - name: Determine LLVM ref
        id: determine_ref
        run: |
          # Use custom ref if provided, otherwise fetch latest stable tag
          if [ -n "${{ github.event.inputs.ref }}" ]; then
            LLVM_REF="${{ github.event.inputs.ref }}"
            echo "Using custom ref: $LLVM_REF"
          else
            # Fetch latest stable LLVM release tag
            LATEST_TAG=$(git ls-remote --tags --refs --sort=-v:refname https://github.com/llvm/llvm-project.git | \
                         grep -Eo 'refs/tags/llvmorg-[0-9.]+$' | sort -V | tail -n1 | sed 's/refs\/tags\///')
            LLVM_REF=$LATEST_TAG
            echo "Using latest tag: $LATEST_TAG"
          fi

          # Extract clang version (remove llvmorg- prefix)
          CLANG_VERSION=$(echo $LLVM_REF | sed 's/llvmorg-//')
          echo "llvm_ref=$LLVM_REF" >> $GITHUB_OUTPUT
          echo "clang_version=$CLANG_VERSION" >> $GITHUB_OUTPUT

      # Add step to get commit SHA
      - name: Get commit SHA
        id: get_sha
        run: |
          if [ -n "${{ github.event.inputs.ref }}" ]; then
            # If custom ref, get its SHA
            COMMIT_SHA=$(git ls-remote https://github.com/llvm/llvm-project.git "${{ github.event.inputs.ref }}" | cut -f1)
          else
            # Use SHA of the latest tag
            COMMIT_SHA=$(git ls-remote --tags --refs --sort=-v:refname https://github.com/llvm/llvm-project.git | \
                         grep -E 'refs/tags/llvmorg-[0-9.]+$' | sort -V | tail -n1 | cut -f1)
          fi
          # Remove any line breaks from the SHA
          COMMIT_SHA=$(echo $COMMIT_SHA | tr -d '\n')
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT

  build-static-clang:
    needs: get-llvm-tag
    # Use Alpine container running on Ubuntu host
    runs-on: ubuntu-latest
    container:
      image: alpine:3.19
    env:
      INSTALL_PREFIX: /llvm-install
      PLATFORM: x86_64
      VERSION: ${{ needs.get-llvm-tag.outputs.clang_version }}

    steps:
      # Install Alpine build dependencies
      - name: Install Alpine build dependencies
        run: |
          apk update
          apk add --no-cache \
            build-base \
            cmake \
            ninja \
            git \
            python3 \
            linux-headers \
            zlib-dev \
            zlib-static \
            curl \
            musl-dev \
            libc-dev \
            binutils \
            file \
            pkgconf

      # Checkout LLVM source code from GitHub
      - name: Checkout LLVM source
        run: |
          LLVM_REF="${{ needs.get-llvm-tag.outputs.llvm_tag }}"

          # Clone specific tag/branch
          if ! git clone --depth 1 --branch $LLVM_REF https://github.com/llvm/llvm-project.git; then
            # Fallback to full clone + checkout for commits
            echo "Cloning full repository (ref may be a commit)"
            git clone https://github.com/llvm/llvm-project.git
            cd llvm-project
            git checkout $LLVM_REF
            cd ..
          fi

      # Apply patch to fix zlib detection issue in CMake
      - name: Patch LLVM CMake configuration
        run: |
          # More robust patch to bypass zlib configuration issues
          patch_file="llvm-project/llvm/cmake/config-ix.cmake"

          # Create backup
          cp "${patch_file}" "${patch_file}.bak"

          echo "Applying zlib configuration patch..."

          # Primary patch method: insert HAVE_ZLIB=1 before the fatal error
          awk '
          /if$$LLVM_ENABLE_ZLIB STREQUAL FORCE_ON AND NOT HAVE_ZLIB$$/ {
            print "  # Patched: Bypassed zlib check for static build"
            print "  set(HAVE_ZLIB 1)"
            print $0
            next
          }
          1
          ' "${patch_file}.bak" > "${patch_file}"

          # Fallback method if primary didn't find match
          if ! grep -q "Patched: Bypassed" "${patch_file}"; then
            echo "Using fallback patching method"
            awk '
            /check_symbol_exists\(compress2/ {
              print "  # Patched: Bypassed compress2 check for static build"
              print "  set(HAVE_ZLIB 1)"
              next
            }
            1
            ' "${patch_file}.bak" > "${patch_file}"
          fi

          # Final verification
          if grep -q "set(HAVE_ZLIB 1)" "${patch_file}"; then
            echo "Patch applied successfully"
            echo "Modified section:"
            grep -A 5 -B 5 "HAVE_ZLIB" "${patch_file}" || true
          else
            echo "ERROR: Patch application failed"
            echo "Problematic section:"
            grep -A 20 -B 20 "ZLIB" "${patch_file}" || true
            exit 1
          fi

      # Configure build environment with necessary flags
      - name: Configure build environment
        run: |
          # Explicitly set zlib paths
          export ZLIB_ROOT=/usr
          echo "ZLIB_ROOT=$ZLIB_ROOT" >> $GITHUB_ENV

          # Set linker flags for static linking
          export LDFLAGS="-static -lz -Wl,--as-needed"
          echo "LDFLAGS=$LDFLAGS" >> $GITHUB_ENV

          # Set compiler flags
          export CXXFLAGS="-static"
          echo "CXXFLAGS=$CXXFLAGS" >> $GITHUB_ENV

          # Verify zlib static library contains required symbols
          echo "Verifying zlib static library:"
          file /usr/lib/libz.a
          nm /usr/lib/libz.a | grep compress2 || echo "Note: compress2 symbol found"

      # Configure the LLVM build with CMake
      - name: Configure LLVM build
        run: |
          mkdir llvm-build
          cd llvm-build

          # Static build configuration with explicit settings
          cmake -G Ninja ../llvm-project/llvm \
            -DCMAKE_BUILD_TYPE=Release \
            -DLLVM_ENABLE_PROJECTS="clang" \
            -DCMAKE_INSTALL_PREFIX=$INSTALL_PREFIX \
            -DBUILD_SHARED_LIBS=OFF \
            -DLLVM_BUILD_LLVM_DYLIB=OFF \
            -DCLANG_LINK_CLANG_DYLIB=OFF \
            -DLLVM_ENABLE_PIC=OFF \
            -DLLVM_INCLUDE_TESTS=OFF \
            -DLLVM_INCLUDE_EXAMPLES=OFF \
            -DLLVM_ENABLE_ZLIB=FORCE_ON \
            -DZLIB_INCLUDE_DIR=/usr/include \
            -DZLIB_LIBRARY=/usr/lib/libz.a \
            -DZLIB_USE_STATIC_LIBS=ON \
            -DLLVM_ENABLE_ZSTD=OFF \
            -DLLVM_ENABLE_LIBXML2=OFF \
            -DLLVM_ENABLE_FFI=OFF \
            -DLLVM_ENABLE_LIBEDIT=OFF \
            -DLLVM_ENABLE_TERMINFO=OFF \
            -DLLVM_ENABLE_LIBPFM=OFF \
            -DLLVM_ENABLE_LIBX86=OFF \
            -DLLVM_ENABLE_ASSERTIONS=OFF \
            -DLLVM_TARGETS_TO_BUILD=X86 \
            -DCOMPILER_RT_BUILD_LIBFUZZER=OFF \
            -DCOMPILER_RT_BUILD_PROFILE=OFF \
            -DCOMPILER_RT_BUILD_SANITIZERS=OFF \
            -DCOMPILER_RT_BUILD_XRAY=OFF \
            -DCMAKE_EXE_LINKER_FLAGS="$LDFLAGS" \
            -DCMAKE_CXX_FLAGS="$CXXFLAGS" \
            -DCMAKE_AR=/usr/bin/ar \
            -DCMAKE_RANLIB=/usr/bin/ranlib

      # Build and install the LLVM/clang components
      - name: Build and install
        run: |
          cd llvm-build
          # Build with all available CPU cores
          ninja -j$(nproc) install

      # Verify generated binaries are truly static
      - name: Verify static binaries
        run: |
          # Check clang binary is statically linked
          if ! file $INSTALL_PREFIX/bin/clang | grep -q "statically linked"; then
            echo "ERROR: clang is not statically linked!"
            file $INSTALL_PREFIX/bin/clang
            exit 1
          fi

          # Check clang++ binary is statically linked
          if ! file $INSTALL_PREFIX/bin/clang++ | grep -q "statically linked"; then
            echo "ERROR: clang++ is not statically linked!"
            file $INSTALL_PREFIX/bin/clang++
            exit 1
          fi

          # Verify binary has no dynamic dependencies
          if ! ldd $INSTALL_PREFIX/bin/clang 2>&1 | grep -q "not a dynamic executable"; then
            echo "ERROR: Binary is not fully static!"
            ldd $INSTALL_PREFIX/bin/clang
            exit 1
          fi

          echo "Verification passed: Binaries are fully static"

      # Package artifacts
      - name: Package artifacts
        run: |
          # Use requested package name format: static-libclang-v{VERSION}-musl-{PLATFORM}
          PACKAGE_NAME="static-libclang-v${VERSION}-musl-${PLATFORM}.tar.gz"
          tar -czvf ${PACKAGE_NAME} -C ${INSTALL_PREFIX} .

          # Prepare artifacts directory
          mkdir -p artifacts
          mv ${PACKAGE_NAME} artifacts/
          echo "Created package: ${PACKAGE_NAME}"

      # Upload artifacts for later release
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: static-clang-alpine
          path: artifacts/*.tar.gz

  # Create GitHub release for the package
  create-release:
    needs: [get-llvm-tag, build-static-clang]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      # Checkout current repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Configure git user for release operations
      - name: Configure Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      # Download build artifacts from previous step
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: static-clang-alpine
          path: artifacts

      # Install GitHub CLI for release management
      - name: Setup GitHub CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y gh

      # Authenticate GitHub CLI using workflow token
      - name: Authenticate GitHub CLI
        run: gh auth login --with-token <<< "${{ secrets.GITHUB_TOKEN }}"

      # Create and push tag for the release
      - name: Create tag and push
        run: |
          VERSION="${{ needs.get-llvm-tag.outputs.clang_version }}"
          RELEASE_TAG="v$VERSION-static-alpine"
          COMMIT_SHA="${{ needs.get-llvm-tag.outputs.commit_sha }}"

          # Create and push tag if it doesn't exist
          if ! git rev-parse $RELEASE_TAG >/dev/null 2>&1; then
            echo "Creating tag $RELEASE_TAG pointing to $COMMIT_SHA"
            git tag $RELEASE_TAG $COMMIT_SHA
            git push origin $RELEASE_TAG
          fi

      # Create GitHub release with release notes
      - name: Create release
        run: |
          VERSION="${{ needs.get-llvm-tag.outputs.clang_version }}"
          RELEASE_TAG="v$VERSION-static-alpine"

          # Generate release notes with build details
          {
            echo "# Static libclang ${{ needs.get-llvm-tag.outputs.clang_version }} (musl)"
            echo ""
            echo "**Build Details:**"
            echo "- LLVM Version: ${{ needs.get-llvm-tag.outputs.llvm_tag }}"
            echo "- Platform: x86_64 Linux"
            echo "- Build Environment: Alpine Linux (musl)"
            echo "- Binary Type: Fully static (except Linux kernel)"
            echo ""
            echo "**Notes:**"
            echo "- Built in Alpine container for pure static linking"
            echo "- Contains clang and clang++ binaries"
            echo "- Package name: static-libclang-v${VERSION}-musl-x86_64.tar.gz"
          } > release_notes.md

          # Create release or update if exists
          if gh release view $RELEASE_TAG >/dev/null 2>&1; then
            echo "Release $RELEASE_TAG already exists, updating..."
            gh release delete $RELEASE_TAG -y --cleanup-tag
          fi

          # Create new release with package
          gh release create "$RELEASE_TAG" \
            artifacts/*.tar.gz \
            --title "Static libclang ${{ needs.get-llvm-tag.outputs.clang_version }} (musl)" \
            --notes-file release_notes.md

      # Verify release was created successfully
      - name: Verify Release
        run: |
          VERSION="${{ needs.get-llvm-tag.outputs.clang_version }}"
          RELEASE_TAG="v$VERSION-static-alpine"
          gh release view $RELEASE_TAG
